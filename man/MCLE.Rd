% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mcle.R
\name{LIR.MCLE.pair}
\alias{LIR.MCLE.pair}
\alias{LIR.MCLE}
\title{Maximal Composite Likelihood Estimate}
\usage{
LIR.MCLE.pair(
  theta,
  model,
  ni,
  nj,
  m,
  tau,
  model_args = list(),
  lower = 0,
  upper = 1,
  optimizer = NULL,
  opt_arg = list(),
  verbose = FALSE
)

LIR.MCLE(
  theta,
  model,
  data,
  tp,
  model_args = list(),
  mtau = Inf,
  lower = 0,
  upper = 1,
  optimizer = NULL,
  opt_arg = list(),
  verbose = FALSE
)
}
\arguments{
\item{theta}{Initial value for parameters to estimate}

\item{model}{Model to calculate \eqn{\hat{R_{\tau}}}}

\item{model_args}{Additional parameters passed to model}

\item{lower}{Lower bound for estimation}

\item{upper}{Upper bound for estimation}

\item{optimizer}{Optimizer to use. Default NULL(which means @seealso [optim()]
will be used). If a user-defined optimizer is applied, it is highly recommended
to wrap this optimizer so that it has the same parameter format as optim().}

\item{opt_arg}{Control list for optimizer. Default empty list}

\item{verbose}{Return detailed output. Default FALSE.}

\item{data}{Observation matrix}

\item{tp}{List-like observation time(1d vector)}

\item{mtau}{The maximum allowable lag time. If a lagged pair has time \eqn{\tau}
greater than `mtau`, it will not be used to calculate composite likelihood.
If `mtau` is less than zero, all pairs will be used. Default -1.0.}
}
\value{
If verbose is TRUE return the full result from optimizer otherwise return MCLE only.
}
\description{
`LIR.MCLE` is for observation matrix input. If number of observation(length(t))
is less than 20000, pairwise data will be pre-calculated and `LIR.CL.pair`
will be used. Otherwise pairwise lagged identification will be calculated
separately at every iteration.
`LIR.MCLE.pair` is for pairwise list data input.(Deprecated)
}
\examples{
# Example of MCLE
# Set observation time
t <- c(1:5, 51:55, 101:105, 501:505, 601:605)
# Generate observation matrix with model C
data <- LIR.simulate.C(300, 100, 605, 40, t, 0.08, 0.04)
# MCLE
LIR.MCLE(rep(0.001, 3), LIR.model.C, data, t)
# [1] 0.007119308 0.212260232 0.003582160

}
